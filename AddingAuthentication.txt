Authentication in React + SPAs

Not really React, but needed in most, if not all application/site!
    - I've no clue how to do it on MultiPageApp, but here we will learn how to use on SPAs

SPA --Auth--> Server (Stateless, RESTful API)

Server --Token--> SPA (token is a JSON that is generated by the Server)

Token is stored in the SPA at a location called 'localStorage' 
    - Not in Redux store, if user reloads page, person is signed out and not authenticated

SPA asks Server for information that is protected, how can we differentiate? If the token says we're valid, then we good homie!
    The SPA will send the token back to the Server, if it is valid, then it will grant permission
    - Examples:
        change password,
        change post,
        change email,
        etc.

Adjustments:
    - Signup & Signin Views
    - Guards
    - Pass Auth information to Backend to use protected services

1. Created UI
    - Auth folder in Containers folder
    - Gave some CSS
    - Stupid error on my part, Input component was not rendering error because of .touched property

2. Creating action creators and thunk methods
    - actions are start, success, fail, auth
    - auth is exported to index
    - import * as actions from  '...'
    - connect to Redux!
    - start probably will just turn loading to true!

Look at Firebase REST auth

3. auth retrieves email, password
    - this will SEND a request for a token! (a JS obj) to firebase
    - server side language to GET API end points and send tokens is A DIFFERENT COURSE
        - firebase already has this, we do not need to set up
    - set email/password ENABLED in firebase
        - refreshToken is used to refresh token since it expires in 3600 seconds, one hour!
        - you can only do this in code!
        - expiresIn, refreshToken, and idToken is important
        - validation will come!
            - an auth reducer!

    - Focus on signing in first!

4. Sign In
    - Cool button trick based on if isSignup! Switch To ...
    - passing in method whether is sign up or sign in
    - don't PASS in arguments directly IN dispatches! 
    - Error message does not show for me.. wtf.
        - it does. error.response! since axios is used, it wrapped it!

5. Creating a reducer for auth to keep token and other functionalities!
    - updateObject error.. no fucking reason. Move on.
    - Main index, added authReducer to combine!
    - Max passed in only localId and idToken, I pass in the whole authData

6. Creating a spinner + showing the error code!
    - {
        "error": {
            "code": 400,
            "message": "EMAIL_EXISTS",
            "errors": [
            {
                "message": "EMAIL_EXISTS",
                "domain": "global",
                "reason": "invalid"
            }
            ]
        }
    }
    
    This is the response! authFail(error) does pass this in!!
    axios wraps the response with the error argument!

    if you see error, do error.response to see the object behind the error!

    Auth form becomes spinner if user presses the log in button
    errorMsg from thunk method --> to action creator --> to reducer --> to Auth.js --> errorMessage inside the return!

7. Logging out
    - 3600 seconds = 1hr, when first passed in in setTimeout, it was 3.6 seconds. D'oh!
    - if user reloads, state is loss, user is logged out
        redux store is cleared
    - got confused in what he was saying
        - after 60 mins, the token "expires"
            we dont see this, we will create something for it
            - we will update UI to reflect the expired token
    
    Created new action type
    Created new methods!
        Action creator
            - logout()
            - checkAuthTimeout()

        Reducer
            - authFail --> updates state, token + id are NULL
            - switch statment


8. Protect! + Logout button
    - In the Database, changing RULES!
        {
            "rules": {
                ".read": true,
                ".write": true,
                "orders": {
                    ".read": "auth != null",
                    ".write": "auth != null"
                }
            }
        }

    - Having read and write as 'true' above OVERWRITES all nested objects
        - CHANGE IT

    Permission is NOW denied when we visit "/orders"
        - we FETCH, and since we are BLOCKED, the fetching of orders does not happen!
        - all this is through axios call
    
    altered the message in withErrorHandler!
        - state.error.response.data.error

    where is ?auth= coming from... firebase?
        - Yes it is... auth is a variable
            it's also a rule, this is how you use it. Just understand this is how you use it.
            I'm sure there's a reason why, just understand that this is how you use it
    
    altering the fetchOrder() method to INCLUDE the token

    UNDERSTAND how the fetch order works with the token and how the token is USED to grab the data thereafter.
    
    flow of data for orders!:
    1. Auth.js - gets email + password + isSignup
    2. auth.js ACTION creator - thunk method, uses the isSignup to change URLS!
    3. response data, contains token + userId (localId) is returned to the reducer
    4. Order.js calls the fetchOrders and passes in token
    5. /orders.json?auth= ... auth is a VARIABLE that is firebase explicit, it is a reserved word. This is how you use auth!
        rule is that orders {read, write} is only true IF auth is not NULL

9. Authorized? We will make it user friendly.. right now, it's not the best UI
    When refreshing page you lose auth..
    Page does tell you if you're auth..
    Logout? ..


    - Added a conditional statement!!
        If isAuthenticated == true, show logout : show sign in @ NavigationalItems.js
        - ** altered Layout.js bc turning NavigationalItems.js into class based component was NOT needed, layout.js is a container!
            added isAuth for Toolbar and SideDrawer props
        - the isAuth is used between Layout, Toolbar, Sidedrawer and NavigationalItems!
            Layout.js
            --> into the components that will see if you're authenticated or not based on a boolean value
            --> state.auth.token !== null is what dictate if you are authenticated or not!

    Logout
        - new Auth subfolder, Logout/Logout.js
            calls the action creator logout from auth.js
            - index.js exports logout
            Redirect is returned, just redirects to root "/"
            - Side adventure
                - relearned how these nav items + tool bar worked
                    - activeClassName is automatically implemented
                        - class="active" in elements
                        - by doing activeClassName={styles.active}
                            it gives the element styling!
                            .active is in the CSS file

            - so when on "/". Burger Builder will be selected,
            - on "/auth" Sign In will be selected
            - React knows what 'exact' will do because of React Router, magic in the back

        Went on a long ass journey bc the fucking styling changed "automatically"!!
            LOL it didnt the exact+activeClassName in NavLink just changed SMH

        
        - Orders is only rendered IF you're authenticated based on the boolean
            Navigation Items!

        - Once signed in, redirect OUT of /auth!
            Auth.js, once you're signed in, 
            Redirect to="/"
        
        - Since the only way to "purchase" is by having a token (authenticated), instead of ORDER NOW, show, SIGN UP!
            Redirect to Sign In!

        - ORDER NOW button needs to redirect to sign up!
            user must sign up first to order

        - conditional statements for the button text, sign up or order now
            in BurgerBuilder.js container push() to /auth if not auth

        - we need to keep burger ingredients AFTER signing in/creating account
            you can store info in the Redux store
                Edit: ings are still kept in the store, nothing has been refreshed or lost

        Side Journey: 
        - render(), what to put inside and what to put before, before = methods, inside = code content, like map()

        - Keeping Ings after signing up!
            'building' prop for burgerBuilder.js, boolean value, if user is buiding a burger or not
            Creating route to go to /checkout and /auth, this is based on if user clicks on the SIGN UP button (shows if not authenticated)
            dynamic approach: 
                - store URL path in auth.js reducer
            onSetAuthRedirectPath()!
                - this is going to change the URL path of Redirect
                - basically saying that it doesnt go straight to checkout page when URL is set to /checkout bc redirect ONLY happens, when you're authenticated.
                    either it goes back to /root, or it goes to /checkout after signing in/ creating account
            Keep in mind, this URL is cleared and reseted, if a condition is met in the componentDidMount() !!,
                - will be sets to "/"
            
        The module section where it Redirects took me the longest today, I couldn't route the flow of things getting passed for the Redirect
            - Now I do:
                When user clicks sign up button and no authenticated, it will set the redirect path to /checkout
                once ON /auth page, when user recieves authorization, instead of redirecting BACK to root, they will be redirected to /checkout

        
10. Persistent State! - Refresh? Are you logged out?
    Every time you refresh the application, you download the SPA again and it's totally new--state is lost.

    We need to persist out log in state across our session!
        Browser API - localStorage (baked into the Browser)
        1. Let's store the token in our localStorage
        2. localStorage is built INTO JavaScript
        3. in the auth.hs action creator, setIem() is used to store the expirationDate and the Token (details in auth.js action creator)
        4. We can inspect localStorage in Chrome Dev Tools, Application Tab --> Local Storage --> Your Domain
        5. In the logout() in auth.js --> removeItem(), remove both props
            We did this so that when we log out, the storage wil remove our information
        6. Signed In? Let's fetch those properties to see if still good!
            - App.js, root component, always loaded no matter what Route we visit
            1. Create new action in auth.js
                - creating so we can dispatch this event along with auth()
                authCheckState + .getItem('token')
                if token is null --> then dispatch logout()
                else --> grab the date obj + token obj
                            ** we must see that if the expirationDate is greater than current date, lets log out! 
                            WE WANT TO LOGIN AFTER.
                            if expirationDate is GREATER than current date then dispatch logout()
                            else dispatch authSuccess()

                        ** we can set everything in LOCAL STORAGE, it's not wrong.
                        But will use the Firebase "Get user data" approach
                        POST:
                        https://identitytoolkit.googleapis.com/v1/accounts:lookup?key=[API_KEY]
                        , Just kidding, local storage is easier.

        ERROR! reaches dispatch(logout()) in auth.js action creator FIRST. WHY?! 
            lets practice break points!
                go sources and add break points
                checkAuthTimeout gave the error!

        ERROR, Max didn't change the token for Orders.js, quick fix by accessing the localStorage and grabbing the token!

11. Ensuring App Security
    - Stored in localStorage, can be accessed by cross site scripting attacks but is protected by React
        - token also expires in an hour
        - Firebase gives us that refreshToken, this does NOT expire.
        - you can ask for a new refresh token for an idToken, so that there's more security!
        - refresh token can be used for good, but you must be careful and protect it! Max explains here.
        - can access in Google Dev Tools/Application Tab/Local Storage/{domain}

12. Gaurd Routes
    Grabbing USER ID and splitting them in Orders data
    - Gaurding the orders page
        just create an if statement! Code is done in App.js
    - Used conditional statement
        if not auth, render auth, 404, / and redirect
        else show all other routes!

    - Protecting data? 
        YES, by the database and token usage


    nicole@nicole.com 123456
    flex@flex.com flexer

13. User Specific Order
    Remember, grab state from other components
        lets say you need state from auth.js reducer in your order.js action creator... how?!
            You do it in the component!
            - order.js action creator fills a spot in its arguments in the dispatched action, check purchaseBurger(), it is then used in ContactData.js
    
    DID IT MY WAY TO VIEW SPECIFIC ORDERS.
        - changed the post URL for order.js action creator!
            `orders/${userId}.json?auth=` + token, orderData (json obj)
            did it for the purchaseBurger()
                orderData.userId

        - changed the get URL for order.js action creator!
            did it for the fetchOrders()
                localStorage-->userId
        
        These methods are used in ContactData.js + Orders.js

    There's a more API way to do it, rather than intuitive way
        - Commented on order.js action creator!!
            - orderBy & equalTo
            - new rule set in Firebase! Filtering happens by ".indexOn" : ["userId"] in Firebase, this is how it is used!
            - 


