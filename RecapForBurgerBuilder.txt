----------------------------------------------------------------------------
1. Planning App
** Things WILL change, and that's perfectly normal.

- Component Tree / Structure
    Create, design and split into components

- Application State (Data) 
    Data we will be using in our application (this.state({...}))

- Component VS Container
    Which components should be Stateless or Stateful

----------------------------------------------------------------------------
2. Layout

- Draw a UI 
    Draw how the website/application will look like
    Nav bar, header, footer, content, images on page, body

Burger Builder
    Burger Picture (dynamic) - bunch of Styled Divs with CSS
    Contents for burger: add/remove cheese, burger, salad, bacon, etc.
    Checkout button, etc.

    App contains --> 
                    layout components  
                                    --> Toolbar
                                        --> Side drawer toggle
                                        --> Logo
                                        --> Nav items

                                    --> Side drawer
                                        -->

                                    --> Backdrop
                                        -->

                                    --> Props + Children
                                        --> Burger Builder (Stateful/Container Class)
                                            --> Build Control
                                                --> Cheese, Meat, Burger
                                                --> Order Button

                                            --> Burger
                                                --> Ingredients will show under the burger component

                                            --> Modal (price, tax, etc.)
                                                --> Wrapper component

----------------------------------------------------------------------------
3. State ( Data )

- this.state({ ingredients: { ..code.. }})
    - purchased, totalprice
    - make it simple!

- Manage the state IN BURGER BUILDER, look at 2. Layout to see the location of Burger Builder.

- Optimize? Pure components, shouldComponentUpdate, etc!

----------------------------------------------------------------------------

Creating Project.

1. Create components
    Think of components you will need for project/use repeatedly
    - Create Aux.js for adjacent JSX, etc.

2. Form layout of project
    Place components where they should go, what components do you need

3. Create folders for components and see where they will go in your source code structure
    Ex. Burger(w/ other sub folders) is in Components 

4. Build components one by one
    Don't be too thorough, just see how the component will work with others!

5. Study code
    Every so often, stop and check code + test! 
        Logic, CSS, etc.

6. Burger Overview
    How is it working?
     - App.js --> Layout.js --> BurgerBuilder.js --> Burger.js --> BurgerIngredients.js
        BurgerIngredients.js returns DIVs that are styled, colors and shap has been altered from a rectangle.

7. Burger Overview Pt. II
    Burger has an interesting tranformation array (by Max), makes sense, confusing to follow tbh for people that doesn't know JS.
     - [...Array([props.ingredients[ingredientKey])] <-- results to [ [undefined], [undefined, undefined] ] 
    
     - One array that has multiple arrays... [ []. [], [] ], and in this case, we only care about the length of the array
       we do not care about the values inside array.

8. Learned some JavaScript methods
    - Note reduce can have an INITIAL value ... could be number, object, array, etc. BurgerBuilder uses [] as initial value, and uses .concat() to combine arrays.
    Using .push() without conditional check will give error. BECAUSE IT RETURNS THE LENGTH OF THE ARRAY AND NOT THE ARRAY ITSELF.

     - .reduce((accumulator, currentValue) => {
         if(currentValue in accumulator){
             accumulator[currentValue]++;
         }
         else {
             accumulator[currentValue] = 1;
         }
         return accumulator;
        }, {})

    - Note that .map can have '_' as blank as an argument that indicates blank, and it will return an array!
     - Here it will return an array of array, objects --> [ [{lol}], [{lol2}], [{lol3}] ]

    The obj.map(key => {
        return [...Array( ..code.. )]
        .map((_, i) => {
            return <JSX />
        }) 
    })
    
9. Added the Burger Control
    How does it work?
     - Less/More button is a <button> with onClick function
        - it takes in an argument, which in this case is 'type'
        - 'type' is collected when the the .map() is initiated in the BuildControl.js
        - When passing, the anonymous function of: () => func(type) is called and passed.
            - when button is clicked, 'type' is passed into the argument and the function runs.
                - FUNCTION takes in argument, grabs the value by this.state.ingredients[type]
                - conditional was created later
                - spread operator was used and the dynamic bracket notation were used
                - price is changed, and I used a Object to keep track of the of price for each item
                - simple calculation of oldPrice + priceOfItem
                - this.setState({...})

    In render?
     - disableLess/disableMore were created
        Grabs the ingredients, then a for loop goes through each one and changes the value to a true or false value
            - it is then passed through components till it hits BuildControl.js and put in 'required={}' inside an HTML button tag

10. Checkout Button
    checkButton state was added, set to false
    created <button> tag in Build Controls, added CSS styling,

    CSS: 
     - new learn:
         - animation: enable–an argument, .4s–the duration of time, linear–kind of animation
         - @keyframes enable { percentages mean the loading of animation from 0% to 100% }

    updatePurchaseState() was added, takes in updatedIngredients argument,
     - called in the methods for adding/deleting ingredients
     - arg is taken because we were taking in OLD STATE which was giving us enexpected behavior

        uses .map() and .reduce()
         - .map() to grab the values inside ingredients obj
         - .reduce() to add the values up
             - if sum is zero, return false.

    In BuildControls.js 
     - disabled={!stateOfButton}
         if TRUE, set disabled, if FALSE, set enabled.
          since sum IS greater than 0, it will be TRUE, we have to !stateOfButton so it is enabled.

11. Modal + Back Drop + Summary
    


